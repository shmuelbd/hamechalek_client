{"ast":null,"code":"function i() {\n  throw new Error(\"Cycle detected\");\n}\nvar t = Symbol.for(\"preact-signals\");\nfunction r() {\n  if (!(v > 1)) {\n    var i,\n      t = !1;\n    while (void 0 !== f) {\n      var r = f;\n      f = void 0;\n      e++;\n      while (void 0 !== r) {\n        var n = r.o;\n        r.o = void 0;\n        r.f &= -3;\n        if (!(8 & r.f) && l(r)) try {\n          r.c();\n        } catch (r) {\n          if (!t) {\n            i = r;\n            t = !0;\n          }\n        }\n        r = n;\n      }\n    }\n    e = 0;\n    v--;\n    if (t) throw i;\n  } else v--;\n}\nfunction n(i) {\n  if (v > 0) return i();\n  v++;\n  try {\n    return i();\n  } finally {\n    r();\n  }\n}\nvar o = void 0,\n  h = 0;\nfunction s(i) {\n  if (h > 0) return i();\n  var t = o;\n  o = void 0;\n  h++;\n  try {\n    return i();\n  } finally {\n    h--;\n    o = t;\n  }\n}\nvar f = void 0,\n  v = 0,\n  e = 0,\n  u = 0;\nfunction c(i) {\n  if (void 0 !== o) {\n    var t = i.n;\n    if (void 0 === t || t.t !== o) {\n      t = {\n        i: 0,\n        S: i,\n        p: o.s,\n        n: void 0,\n        t: o,\n        e: void 0,\n        x: void 0,\n        r: t\n      };\n      if (void 0 !== o.s) o.s.n = t;\n      o.s = t;\n      i.n = t;\n      if (32 & o.f) i.S(t);\n      return t;\n    } else if (-1 === t.i) {\n      t.i = 0;\n      if (void 0 !== t.n) {\n        t.n.p = t.p;\n        if (void 0 !== t.p) t.p.n = t.n;\n        t.p = o.s;\n        t.n = void 0;\n        o.s.n = t;\n        o.s = t;\n      }\n      return t;\n    }\n  }\n}\nfunction d(i) {\n  this.v = i;\n  this.i = 0;\n  this.n = void 0;\n  this.t = void 0;\n}\nd.prototype.brand = t;\nd.prototype.h = function () {\n  return !0;\n};\nd.prototype.S = function (i) {\n  if (this.t !== i && void 0 === i.e) {\n    i.x = this.t;\n    if (void 0 !== this.t) this.t.e = i;\n    this.t = i;\n  }\n};\nd.prototype.U = function (i) {\n  if (void 0 !== this.t) {\n    var t = i.e,\n      r = i.x;\n    if (void 0 !== t) {\n      t.x = r;\n      i.e = void 0;\n    }\n    if (void 0 !== r) {\n      r.e = t;\n      i.x = void 0;\n    }\n    if (i === this.t) this.t = r;\n  }\n};\nd.prototype.subscribe = function (i) {\n  var t = this;\n  return O(function () {\n    var r = t.value,\n      n = 32 & this.f;\n    this.f &= -33;\n    try {\n      i(r);\n    } finally {\n      this.f |= n;\n    }\n  });\n};\nd.prototype.valueOf = function () {\n  return this.value;\n};\nd.prototype.toString = function () {\n  return this.value + \"\";\n};\nd.prototype.toJSON = function () {\n  return this.value;\n};\nd.prototype.peek = function () {\n  return this.v;\n};\nObject.defineProperty(d.prototype, \"value\", {\n  get: function get() {\n    var i = c(this);\n    if (void 0 !== i) i.i = this.i;\n    return this.v;\n  },\n  set: function set(t) {\n    if (o instanceof _) !function () {\n      throw new Error(\"Computed cannot have side-effects\");\n    }();\n    if (t !== this.v) {\n      if (e > 100) i();\n      this.v = t;\n      this.i++;\n      u++;\n      v++;\n      try {\n        for (var n = this.t; void 0 !== n; n = n.x) n.t.N();\n      } finally {\n        r();\n      }\n    }\n  }\n});\nfunction a(i) {\n  return new d(i);\n}\nfunction l(i) {\n  for (var t = i.s; void 0 !== t; t = t.n) if (t.S.i !== t.i || !t.S.h() || t.S.i !== t.i) return !0;\n  return !1;\n}\nfunction y(i) {\n  for (var t = i.s; void 0 !== t; t = t.n) {\n    var r = t.S.n;\n    if (void 0 !== r) t.r = r;\n    t.S.n = t;\n    t.i = -1;\n    if (void 0 === t.n) {\n      i.s = t;\n      break;\n    }\n  }\n}\nfunction w(i) {\n  var t = i.s,\n    r = void 0;\n  while (void 0 !== t) {\n    var n = t.p;\n    if (-1 === t.i) {\n      t.S.U(t);\n      if (void 0 !== n) n.n = t.n;\n      if (void 0 !== t.n) t.n.p = n;\n    } else r = t;\n    t.S.n = t.r;\n    if (void 0 !== t.r) t.r = void 0;\n    t = n;\n  }\n  i.s = r;\n}\nfunction _(i) {\n  d.call(this, void 0);\n  this.x = i;\n  this.s = void 0;\n  this.g = u - 1;\n  this.f = 4;\n}\n(_.prototype = new d()).h = function () {\n  this.f &= -3;\n  if (1 & this.f) return !1;\n  if (32 == (36 & this.f)) return !0;\n  this.f &= -5;\n  if (this.g === u) return !0;\n  this.g = u;\n  this.f |= 1;\n  if (this.i > 0 && !l(this)) {\n    this.f &= -2;\n    return !0;\n  }\n  var i = o;\n  try {\n    y(this);\n    o = this;\n    var t = this.x();\n    if (16 & this.f || this.v !== t || 0 === this.i) {\n      this.v = t;\n      this.f &= -17;\n      this.i++;\n    }\n  } catch (i) {\n    this.v = i;\n    this.f |= 16;\n    this.i++;\n  }\n  o = i;\n  w(this);\n  this.f &= -2;\n  return !0;\n};\n_.prototype.S = function (i) {\n  if (void 0 === this.t) {\n    this.f |= 36;\n    for (var t = this.s; void 0 !== t; t = t.n) t.S.S(t);\n  }\n  d.prototype.S.call(this, i);\n};\n_.prototype.U = function (i) {\n  if (void 0 !== this.t) {\n    d.prototype.U.call(this, i);\n    if (void 0 === this.t) {\n      this.f &= -33;\n      for (var t = this.s; void 0 !== t; t = t.n) t.S.U(t);\n    }\n  }\n};\n_.prototype.N = function () {\n  if (!(2 & this.f)) {\n    this.f |= 6;\n    for (var i = this.t; void 0 !== i; i = i.x) i.t.N();\n  }\n};\n_.prototype.peek = function () {\n  if (!this.h()) i();\n  if (16 & this.f) throw this.v;\n  return this.v;\n};\nObject.defineProperty(_.prototype, \"value\", {\n  get: function get() {\n    if (1 & this.f) i();\n    var t = c(this);\n    this.h();\n    if (void 0 !== t) t.i = this.i;\n    if (16 & this.f) throw this.v;\n    return this.v;\n  }\n});\nfunction p(i) {\n  return new _(i);\n}\nfunction g(i) {\n  var t = i.u;\n  i.u = void 0;\n  if (\"function\" == typeof t) {\n    v++;\n    var n = o;\n    o = void 0;\n    try {\n      t();\n    } catch (t) {\n      i.f &= -2;\n      i.f |= 8;\n      b(i);\n      throw t;\n    } finally {\n      o = n;\n      r();\n    }\n  }\n}\nfunction b(i) {\n  for (var t = i.s; void 0 !== t; t = t.n) t.S.U(t);\n  i.x = void 0;\n  i.s = void 0;\n  g(i);\n}\nfunction x(i) {\n  if (o !== this) throw new Error(\"Out-of-order effect\");\n  w(this);\n  o = i;\n  this.f &= -2;\n  if (8 & this.f) b(this);\n  r();\n}\nfunction E(i) {\n  this.x = i;\n  this.u = void 0;\n  this.s = void 0;\n  this.o = void 0;\n  this.f = 32;\n}\nE.prototype.c = function () {\n  var i = this.S();\n  try {\n    if (8 & this.f) return;\n    if (void 0 === this.x) return;\n    var t = this.x();\n    if (\"function\" == typeof t) this.u = t;\n  } finally {\n    i();\n  }\n};\nE.prototype.S = function () {\n  if (1 & this.f) i();\n  this.f |= 1;\n  this.f &= -9;\n  g(this);\n  y(this);\n  v++;\n  var t = o;\n  o = this;\n  return x.bind(this, t);\n};\nE.prototype.N = function () {\n  if (!(2 & this.f)) {\n    this.f |= 2;\n    this.o = f;\n    f = this;\n  }\n};\nE.prototype.d = function () {\n  this.f |= 8;\n  if (!(1 & this.f)) b(this);\n};\nfunction O(i) {\n  var t = new E(i);\n  try {\n    t.c();\n  } catch (i) {\n    t.d();\n    throw i;\n  }\n  return t.d.bind(t);\n}\nexport { d as Signal, n as batch, p as computed, O as effect, a as signal, s as untracked };","map":{"version":3,"names":["i","Error","t","Symbol","for","r","v","f","e","n","o","l","c","h","s","u","S","p","x","d","prototype","brand","U","subscribe","O","value","valueOf","toString","toJSON","peek","Object","defineProperty","get","set","_","N","a","y","w","call","g","b","E","bind","Signal","batch","computed","effect","signal","untracked"],"sources":["C:\\Users\\USER\\Documents\\GitHub\\hamechalek_client\\node_modules\\@preact\\signals-core\\src\\index.ts"],"sourcesContent":["function cycleDetected(): never {\n\tthrow new Error(\"Cycle detected\");\n}\nfunction mutationDetected(): never {\n\tthrow new Error(\"Computed cannot have side-effects\");\n}\n\nconst identifier = Symbol.for('preact-signals')\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\nfunction batch<T>(callback: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn callback();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn callback();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\nlet untrackedDepth = 0;\n\nfunction untracked<T>(callback: () => T): T {\n\tif (untrackedDepth > 0) {\n\t\treturn callback();\n\t}\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\tuntrackedDepth++;\n\ttry {\n\t\treturn callback();\n\t} finally {\n\t\tuntrackedDepth--;\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n// @ts-ignore internal Signal is viewed as a function\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof identifier;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\n/** @internal */\n// @ts-ignore internal Signal is viewed as function\nfunction Signal(this: Signal, value?: unknown) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n}\n\nSignal.prototype.brand = identifier\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tif (this._targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = this._targets;\n\t\tif (this._targets !== undefined) {\n\t\t\tthis._targets._prevTarget = node;\n\t\t}\n\t\tthis._targets = node;\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\tconst signal = this;\n\treturn effect(function (this: Effect) {\n\t\tconst value = signal.value;\n\t\tconst flag = this._flags & TRACKING;\n\t\tthis._flags &= ~TRACKING;\n\t\ttry {\n\t\t\tfn(value);\n\t\t} finally {\n\t\t\tthis._flags |= flag;\n\t\t}\n\t});\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\treturn this._value;\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget() {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (evalContext instanceof Computed) {\n\t\t\tmutationDetected();\n\t\t}\n\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tcycleDetected();\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\nfunction signal<T>(value: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\t// If there's a new version of the dependency before or after refreshing,\n\t\t// or the dependency has something blocking it from refreshing at all (e.g. a\n\t\t// dependency cycle), then we need to recompute.\n\t\tif (\n\t\t\tnode._source._version !== node._version ||\n\t\t\t!node._source._refresh() ||\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n\t_compute: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(compute: () => T);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\nfunction Computed(this: Computed, compute: () => unknown) {\n\tSignal.call(this, undefined);\n\n\tthis._compute = compute;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._compute();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when the it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nComputed.prototype.peek = function () {\n\tif (!this._refresh()) {\n\t\tcycleDetected();\n\t}\n\tif (this._flags & HAS_ERROR) {\n\t\tthrow this._value;\n\t}\n\treturn this._value;\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget() {\n\t\tif (this._flags & RUNNING) {\n\t\t\tcycleDetected();\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\ninterface ReadonlySignal<T = any> extends Signal<T> {\n\treadonly value: T;\n}\n\nfunction computed<T>(compute: () => T): ReadonlySignal<T> {\n\treturn new Computed(compute);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._compute = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectCleanup = () => unknown;\ndeclare class Effect {\n\t_compute?: () => unknown | EffectCleanup;\n\t_cleanup?: () => unknown;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\n\tconstructor(compute: () => unknown | EffectCleanup);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n}\n\nfunction Effect(this: Effect, compute: () => unknown | EffectCleanup) {\n\tthis._compute = compute;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._compute === undefined) return;\n\n\t\tconst cleanup = this._compute();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup as EffectCleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tcycleDetected();\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\nfunction effect(compute: () => unknown | EffectCleanup): () => void {\n\tconst effect = new Effect(compute);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\treturn effect._dispose.bind(effect);\n}\n\nexport {\n\tsignal,\n\tcomputed,\n\teffect,\n\tbatch,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}