{"ast":null,"code":"import { Component as n, options as r, isValidElement as i } from \"preact\";\nimport { useMemo as t, useRef as f, useEffect as o } from \"preact/hooks\";\nimport { Signal as e, computed as u, signal as a, effect as c } from \"@preact/signals-core\";\nexport { Signal, batch, computed, effect, signal, untracked } from \"@preact/signals-core\";\nvar v, s;\nfunction l(n, i) {\n  r[n] = i.bind(null, r[n] || function () {});\n}\nfunction d(n) {\n  if (s) s();\n  s = n && n.S();\n}\nfunction p(n) {\n  var r = this,\n    f = n.data,\n    o = useSignal(f);\n  o.value = f;\n  var e = t(function () {\n    var n = r.__v;\n    while (n = n.__) if (n.__c) {\n      n.__c.__$f |= 4;\n      break;\n    }\n    r.__$u.c = function () {\n      var n;\n      if (!i(e.peek()) && 3 === (null == (n = r.base) ? void 0 : n.nodeType)) r.base.data = e.peek();else {\n        r.__$f |= 1;\n        r.setState({});\n      }\n    };\n    return u(function () {\n      var n = o.value.value;\n      return 0 === n ? 0 : !0 === n ? \"\" : n || \"\";\n    });\n  }, []);\n  return e.value;\n}\np.displayName = \"_st\";\nObject.defineProperties(e.prototype, {\n  constructor: {\n    configurable: !0,\n    value: void 0\n  },\n  type: {\n    configurable: !0,\n    value: p\n  },\n  props: {\n    configurable: !0,\n    get: function () {\n      return {\n        data: this\n      };\n    }\n  },\n  __b: {\n    configurable: !0,\n    value: 1\n  }\n});\nl(\"__b\", function (n, r) {\n  if (\"string\" == typeof r.type) {\n    var i,\n      t = r.props;\n    for (var f in t) if (\"children\" !== f) {\n      var o = t[f];\n      if (o instanceof e) {\n        if (!i) r.__np = i = {};\n        i[f] = o;\n        t[f] = o.peek();\n      }\n    }\n  }\n  n(r);\n});\nl(\"__r\", function (n, r) {\n  d();\n  var i,\n    t = r.__c;\n  if (t) {\n    t.__$f &= -2;\n    if (void 0 === (i = t.__$u)) t.__$u = i = function (n) {\n      var r;\n      c(function () {\n        r = this;\n      });\n      r.c = function () {\n        t.__$f |= 1;\n        t.setState({});\n      };\n      return r;\n    }();\n  }\n  v = t;\n  d(i);\n  n(r);\n});\nl(\"__e\", function (n, r, i, t) {\n  d();\n  v = void 0;\n  n(r, i, t);\n});\nl(\"diffed\", function (n, r) {\n  d();\n  v = void 0;\n  var i;\n  if (\"string\" == typeof r.type && (i = r.__e)) {\n    var t = r.__np,\n      f = r.props;\n    if (t) {\n      var o = i.U;\n      if (o) for (var e in o) {\n        var u = o[e];\n        if (void 0 !== u && !(e in t)) {\n          u.d();\n          o[e] = void 0;\n        }\n      } else i.U = o = {};\n      for (var a in t) {\n        var c = o[a],\n          s = t[a];\n        if (void 0 === c) {\n          c = _(i, a, s, f);\n          o[a] = c;\n        } else c.o(s, f);\n      }\n    }\n  }\n  n(r);\n});\nfunction _(n, r, i, t) {\n  var f = r in n && void 0 === n.ownerSVGElement,\n    o = a(i);\n  return {\n    o: function (n, r) {\n      o.value = n;\n      t = r;\n    },\n    d: c(function () {\n      var i = o.value.value;\n      if (t[r] !== i) {\n        t[r] = i;\n        if (f) n[r] = i;else if (i) n.setAttribute(r, i);else n.removeAttribute(r);\n      }\n    })\n  };\n}\nl(\"unmount\", function (n, r) {\n  if (\"string\" == typeof r.type) {\n    var i = r.__e;\n    if (i) {\n      var t = i.U;\n      if (t) {\n        i.U = void 0;\n        for (var f in t) {\n          var o = t[f];\n          if (o) o.d();\n        }\n      }\n    }\n  } else {\n    var e = r.__c;\n    if (e) {\n      var u = e.__$u;\n      if (u) {\n        e.__$u = void 0;\n        u.d();\n      }\n    }\n  }\n  n(r);\n});\nl(\"__h\", function (n, r, i, t) {\n  if (t < 3 || 9 === t) r.__$f |= 2;\n  n(r, i, t);\n});\nn.prototype.shouldComponentUpdate = function (n, r) {\n  var i = this.__$u;\n  if (!(i && void 0 !== i.s || 4 & this.__$f)) return !0;\n  if (3 & this.__$f) return !0;\n  for (var t in r) return !0;\n  for (var f in n) if (\"__source\" !== f && n[f] !== this.props[f]) return !0;\n  for (var o in this.props) if (!(o in n)) return !0;\n  return !1;\n};\nfunction useSignal(n) {\n  return t(function () {\n    return a(n);\n  }, []);\n}\nfunction useComputed(n) {\n  var r = f(n);\n  r.current = n;\n  v.__$f |= 4;\n  return t(function () {\n    return u(function () {\n      return r.current();\n    });\n  }, []);\n}\nfunction useSignalEffect(n) {\n  var r = f(n);\n  r.current = n;\n  o(function () {\n    return c(function () {\n      return r.current();\n    });\n  }, []);\n}\nexport { useComputed, useSignal, useSignalEffect };","map":{"version":3,"names":["n","options","r","isValidElement","i","useMemo","t","useRef","f","useEffect","o","Signal","e","computed","u","signal","a","effect","c","batch","untracked","v","s","l","bind","d","S","p","data","useSignal","value","__v","__","__c","__$f","__$u","peek","base","nodeType","setState","displayName","Object","defineProperties","prototype","constructor","configurable","type","props","get","__b","__np","__e","U","_","ownerSVGElement","_update","setAttribute","removeAttribute","shouldComponentUpdate","useComputed","current","useSignalEffect"],"sources":["/workspaces/hamechalek_client/node_modules/@preact/signals/src/index.ts"],"sourcesContent":["import { options, Component, isValidElement } from \"preact\";\nimport { useRef, useMemo, useEffect } from \"preact/hooks\";\nimport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n} from \"@preact/signals-core\";\nimport {\n\tVNode,\n\tOptionsTypes,\n\tHookFn,\n\tEffect,\n\tPropertyUpdater,\n\tAugmentedComponent,\n\tAugmentedElement as Element,\n} from \"./internal\";\n\nexport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n};\n\nconst HAS_PENDING_UPDATE = 1 << 0;\nconst HAS_HOOK_STATE = 1 << 1;\nconst HAS_COMPUTEDS = 1 << 2;\n\n// Install a Preact options hook\nfunction hook<T extends OptionsTypes>(hookName: T, hookFn: HookFn<T>) {\n\t// @ts-ignore-next-line private options hooks usage\n\toptions[hookName] = hookFn.bind(null, options[hookName] || (() => {}));\n}\n\nlet currentComponent: AugmentedComponent | undefined;\nlet finishUpdate: (() => void) | undefined;\n\nfunction setCurrentUpdater(updater?: Effect) {\n\t// end tracking for the current update:\n\tif (finishUpdate) finishUpdate();\n\t// start tracking the new update:\n\tfinishUpdate = updater && updater._start();\n}\n\nfunction createUpdater(update: () => void) {\n\tlet updater!: Effect;\n\teffect(function (this: Effect) {\n\t\tupdater = this;\n\t});\n\tupdater._callback = update;\n\treturn updater;\n}\n\n/** @todo This may be needed for complex prop value detection. */\n// function isSignalValue(value: any): value is Signal {\n// \tif (typeof value !== \"object\" || value == null) return false;\n// \tif (value instanceof Signal) return true;\n// \t// @TODO: uncomment this when we land Reactive (ideally behind a brand check)\n// \t// for (let i in value) if (value[i] instanceof Signal) return true;\n// \treturn false;\n// }\n\n/**\n * A wrapper component that renders a Signal directly as a Text node.\n * @todo: in Preact 11, just decorate Signal with `type:null`\n */\nfunction SignalValue(this: AugmentedComponent, { data }: { data: Signal }) {\n\t// hasComputeds.add(this);\n\n\t// Store the props.data signal in another signal so that\n\t// passing a new signal reference re-runs the text computed:\n\tconst currentSignal = useSignal(data);\n\tcurrentSignal.value = data;\n\n\tconst s = useMemo(() => {\n\t\t// mark the parent component as having computeds so it gets optimized\n\t\tlet v = this.__v;\n\t\twhile ((v = v.__!)) {\n\t\t\tif (v.__c) {\n\t\t\t\tv.__c._updateFlags |= HAS_COMPUTEDS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis._updater!._callback = () => {\n\t\t\tif (isValidElement(s.peek()) || this.base?.nodeType !== 3) {\n\t\t\t\tthis._updateFlags |= HAS_PENDING_UPDATE;\n\t\t\t\tthis.setState({});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t(this.base as Text).data = s.peek();\n\t\t};\n\n\t\treturn computed(() => {\n\t\t\tlet data = currentSignal.value;\n\t\t\tlet s = data.value;\n\t\t\treturn s === 0 ? 0 : s === true ? \"\" : s || \"\";\n\t\t});\n\t}, []);\n\n\treturn s.value;\n}\nSignalValue.displayName = \"_st\";\n\nObject.defineProperties(Signal.prototype, {\n\tconstructor: { configurable: true, value: undefined },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\t// Setting a VNode's _depth to 1 forces Preact to clone it before modifying:\n\t// https://github.com/preactjs/preact/blob/d7a433ee8463a7dc23a05111bb47de9ec729ad4d/src/diff/children.js#L77\n\t// @todo remove this for Preact 11\n\t__b: { configurable: true, value: 1 },\n});\n\n/** Inject low-level property/attribute bindings for Signals into Preact's diff */\nhook(OptionsTypes.DIFF, (old, vnode) => {\n\tif (typeof vnode.type === \"string\") {\n\t\tlet signalProps: Record<string, any> | undefined;\n\n\t\tlet props = vnode.props;\n\t\tfor (let i in props) {\n\t\t\tif (i === \"children\") continue;\n\n\t\t\tlet value = props[i];\n\t\t\tif (value instanceof Signal) {\n\t\t\t\tif (!signalProps) vnode.__np = signalProps = {};\n\t\t\t\tsignalProps[i] = value;\n\t\t\t\tprops[i] = value.peek();\n\t\t\t}\n\t\t}\n\t}\n\n\told(vnode);\n});\n\n/** Set up Updater before rendering a component */\nhook(OptionsTypes.RENDER, (old, vnode) => {\n\tsetCurrentUpdater();\n\n\tlet updater;\n\n\tlet component = vnode.__c;\n\tif (component) {\n\t\tcomponent._updateFlags &= ~HAS_PENDING_UPDATE;\n\n\t\tupdater = component._updater;\n\t\tif (updater === undefined) {\n\t\t\tcomponent._updater = updater = createUpdater(() => {\n\t\t\t\tcomponent._updateFlags |= HAS_PENDING_UPDATE;\n\t\t\t\tcomponent.setState({});\n\t\t\t});\n\t\t}\n\t}\n\n\tcurrentComponent = component;\n\tsetCurrentUpdater(updater);\n\told(vnode);\n});\n\n/** Finish current updater if a component errors */\nhook(OptionsTypes.CATCH_ERROR, (old, error, vnode, oldVNode) => {\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\told(error, vnode, oldVNode);\n});\n\n/** Finish current updater after rendering any VNode */\nhook(OptionsTypes.DIFFED, (old, vnode) => {\n\tsetCurrentUpdater();\n\tcurrentComponent = undefined;\n\n\tlet dom: Element;\n\n\t// vnode._dom is undefined during string rendering,\n\t// so we use this to skip prop subscriptions during SSR.\n\tif (typeof vnode.type === \"string\" && (dom = vnode.__e as Element)) {\n\t\tlet props = vnode.__np;\n\t\tlet renderedProps = vnode.props;\n\t\tif (props) {\n\t\t\tlet updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater !== undefined && !(prop in props)) {\n\t\t\t\t\t\tupdater._dispose();\n\t\t\t\t\t\t// @todo we could just always invoke _dispose() here\n\t\t\t\t\t\tupdaters[prop] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tupdaters = {};\n\t\t\t\tdom._updaters = updaters;\n\t\t\t}\n\t\t\tfor (let prop in props) {\n\t\t\t\tlet updater = updaters[prop];\n\t\t\t\tlet signal = props[prop];\n\t\t\t\tif (updater === undefined) {\n\t\t\t\t\tupdater = createPropUpdater(dom, prop, signal, renderedProps);\n\t\t\t\t\tupdaters[prop] = updater;\n\t\t\t\t} else {\n\t\t\t\t\tupdater._update(signal, renderedProps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\nfunction createPropUpdater(\n\tdom: Element,\n\tprop: string,\n\tpropSignal: Signal,\n\tprops: Record<string, any>\n): PropertyUpdater {\n\tconst setAsProperty =\n\t\tprop in dom &&\n\t\t// SVG elements need to go through `setAttribute` because they\n\t\t// expect things like SVGAnimatedTransformList instead of strings.\n\t\t// @ts-ignore\n\t\tdom.ownerSVGElement === undefined;\n\n\tconst changeSignal = signal(propSignal);\n\treturn {\n\t\t_update: (newSignal: Signal, newProps: typeof props) => {\n\t\t\tchangeSignal.value = newSignal;\n\t\t\tprops = newProps;\n\t\t},\n\t\t_dispose: effect(() => {\n\t\t\tconst value = changeSignal.value.value;\n\t\t\t// If Preact just rendered this value, don't render it again:\n\t\t\tif (props[prop] === value) return;\n\t\t\tprops[prop] = value;\n\t\t\tif (setAsProperty) {\n\t\t\t\t// @ts-ignore-next-line silly\n\t\t\t\tdom[prop] = value;\n\t\t\t} else if (value) {\n\t\t\t\tdom.setAttribute(prop, value);\n\t\t\t} else {\n\t\t\t\tdom.removeAttribute(prop);\n\t\t\t}\n\t\t}),\n\t};\n}\n\n/** Unsubscribe from Signals when unmounting components/vnodes */\nhook(OptionsTypes.UNMOUNT, (old, vnode: VNode) => {\n\tif (typeof vnode.type === \"string\") {\n\t\tlet dom = vnode.__e as Element | undefined;\n\t\t// vnode._dom is undefined during string rendering\n\t\tif (dom) {\n\t\t\tconst updaters = dom._updaters;\n\t\t\tif (updaters) {\n\t\t\t\tdom._updaters = undefined;\n\t\t\t\tfor (let prop in updaters) {\n\t\t\t\t\tlet updater = updaters[prop];\n\t\t\t\t\tif (updater) updater._dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tlet component = vnode.__c;\n\t\tif (component) {\n\t\t\tconst updater = component._updater;\n\t\t\tif (updater) {\n\t\t\t\tcomponent._updater = undefined;\n\t\t\t\tupdater._dispose();\n\t\t\t}\n\t\t}\n\t}\n\told(vnode);\n});\n\n/** Mark components that use hook state so we can skip sCU optimization. */\nhook(OptionsTypes.HOOK, (old, component, index, type) => {\n\tif (type < 3 || type === 9)\n\t\t(component as AugmentedComponent)._updateFlags |= HAS_HOOK_STATE;\n\told(component, index, type);\n});\n\n/**\n * Auto-memoize components that use Signals/Computeds.\n * Note: Does _not_ optimize components that use hook/class state.\n */\nComponent.prototype.shouldComponentUpdate = function (\n\tthis: AugmentedComponent,\n\tprops,\n\tstate\n) {\n\t// @todo: Once preactjs/preact#3671 lands, this could just use `currentUpdater`:\n\tconst updater = this._updater;\n\tconst hasSignals = updater && updater._sources !== undefined;\n\n\t// let reason;\n\t// if (!hasSignals && !hasComputeds.has(this)) {\n\t// \treason = \"no signals or computeds\";\n\t// } else if (hasPendingUpdate.has(this)) {\n\t// \treason = \"has pending update\";\n\t// } else if (hasHookState.has(this)) {\n\t// \treason = \"has hook state\";\n\t// }\n\t// if (reason) {\n\t// \tif (!this) reason += \" (`this` bug)\";\n\t// \tconsole.log(\"not optimizing\", this?.constructor?.name, \": \", reason, {\n\t// \t\tdetails: {\n\t// \t\t\thasSignals,\n\t// \t\t\thasComputeds: hasComputeds.has(this),\n\t// \t\t\thasPendingUpdate: hasPendingUpdate.has(this),\n\t// \t\t\thasHookState: hasHookState.has(this),\n\t// \t\t\tdeps: Array.from(updater._deps),\n\t// \t\t\tupdater,\n\t// \t\t},\n\t// \t});\n\t// }\n\n\t// if this component used no signals or computeds, update:\n\tif (!hasSignals && !(this._updateFlags & HAS_COMPUTEDS)) return true;\n\n\t// if there is a pending re-render triggered from Signals,\n\t// or if there is hook or class state, update:\n\tif (this._updateFlags & (HAS_PENDING_UPDATE | HAS_HOOK_STATE)) return true;\n\n\t// @ts-ignore\n\tfor (let i in state) return true;\n\n\t// if any non-Signal props changed, update:\n\tfor (let i in props) {\n\t\tif (i !== \"__source\" && props[i] !== this.props[i]) return true;\n\t}\n\tfor (let i in this.props) if (!(i in props)) return true;\n\n\t// this is a purely Signal-driven component, don't update:\n\treturn false;\n};\n\nexport function useSignal<T>(value: T) {\n\treturn useMemo(() => signal<T>(value), []);\n}\n\nexport function useComputed<T>(compute: () => T) {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\t(currentComponent as AugmentedComponent)._updateFlags |= HAS_COMPUTEDS;\n\treturn useMemo(() => computed<T>(() => $compute.current()), []);\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(() => callback.current());\n\t}, []);\n}\n\n/**\n * @todo Determine which Reactive implementation we'll be using.\n * @internal\n */\n// export function useReactive<T extends object>(value: T): Reactive<T> {\n// \treturn useMemo(() => reactive<T>(value), []);\n// }\n\n/**\n * @internal\n * Update a Reactive's using the properties of an object or other Reactive.\n * Also works for Signals.\n * @example\n *   // Update a Reactive with Object.assign()-like syntax:\n *   const r = reactive({ name: \"Alice\" });\n *   update(r, { name: \"Bob\" });\n *   update(r, { age: 42 }); // property 'age' does not exist in type '{ name?: string }'\n *   update(r, 2); // '2' has no properties in common with '{ name?: string }'\n *   console.log(r.name.value); // \"Bob\"\n *\n * @example\n *   // Update a Reactive with the properties of another Reactive:\n *   const A = reactive({ name: \"Alice\" });\n *   const B = reactive({ name: \"Bob\", age: 42 });\n *   update(A, B);\n *   console.log(`${A.name} is ${A.age}`); // \"Bob is 42\"\n *\n * @example\n *   // Update a signal with assign()-like syntax:\n *   const s = signal(42);\n *   update(s, \"hi\"); // Argument type 'string' not assignable to type 'number'\n *   update(s, {}); // Argument type '{}' not assignable to type 'number'\n *   update(s, 43);\n *   console.log(s.value); // 43\n *\n * @param obj The Reactive or Signal to be updated\n * @param update The value, Signal, object or Reactive to update `obj` to match\n * @param overwrite If `true`, any properties `obj` missing from `update` are set to `undefined`\n */\n/*\nexport function update<T extends SignalOrReactive>(\n\tobj: T,\n\tupdate: Partial<Unwrap<T>>,\n\toverwrite = false\n) {\n\tif (obj instanceof Signal) {\n\t\tobj.value = peekValue(update);\n\t} else {\n\t\tfor (let i in update) {\n\t\t\tif (i in obj) {\n\t\t\t\tobj[i].value = peekValue(update[i]);\n\t\t\t} else {\n\t\t\t\tlet sig = signal(peekValue(update[i]));\n\t\t\t\tsig[KEY] = i;\n\t\t\t\tobj[i] = sig;\n\t\t\t}\n\t\t}\n\t\tif (overwrite) {\n\t\t\tfor (let i in obj) {\n\t\t\t\tif (!(i in update)) {\n\t\t\t\t\tobj[i].value = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n*/\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}